[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R Assessment for STC position at Global Poverty and Inequality Data Team",
    "section": "",
    "text": "Author: Nolan Young Zabala\nContact: youngnolan1@gmail.com\n\nLibraries\n\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(Hmisc)\nlibrary(DT)\n\n*Note: package “Hmisc” is used for weighted mean and variance calculations. Like “dplyr”, it contains the function “summarize” - so make sure to use “dplyr:summarize” to avoid confusing errors.\n\n\nBasic Stats\n\nData download\n\ntag      &lt;- \"202311081903\"\nbase_url &lt;- \"https://github.com/randrescastaneda/pub_data/raw/\"\ndata_url &lt;- paste0(base_url, tag, \"/data/Rtest1/\")\n\n\nwdi_in1 &lt;- readr::read_rds(paste0(data_url, \"wdi_in1.Rds\"))\n\nwdi_summ_solution &lt;- readr::read_rds(paste0(data_url, \"wdi_summ_out.Rds\"))\n\nwdi_agg_solution &lt;- readr::read_rds(paste0(data_url, \"wdi_agg_out.Rds\"))\n\nwdi_outliers_solution &lt;- readr::read_rds(paste0(data_url, \"wdi_outliers_out.Rds\"))\n\n\n\n1. Summary statistics of GDP per capita by region\n\n# Create a new dataframe with population-weighted summary stats \nwdi_summ_answer &lt;- wdi_in1 %&gt;%\n  rename(year = date) %&gt;% \n  group_by(region, year) %&gt;% \n  dplyr::summarize(N = n(),\n            Mean = wtd.mean(gdp, pop),\n            SD = sqrt(wtd.var(gdp, pop)),\n            Min = min(gdp),\n            Max = max(gdp)\n                   )\n\n# Display preview of answer\ndatatable(wdi_summ_answer, \n          options = list(pageLength = 10, lengthMenu = c(10, 20, 30), searching = TRUE), \n          style = \"bootstrap\",\n          class = \"display responsive nowrap\")%&gt;% \n  formatRound(columns=c(\"Mean\", \"SD\", \"Min\", \"Max\"), digits=2)\n\n\n\n\n\n\n\n\n2. Aggregate stats\nFirst, define function “aggregate_stat”, which takes the indicator of interest as an argument (string), and returns a long-format dataframe containing population-weighted summary statistics for the indicator of interest.\n\naggregate_stat &lt;- function(indicator) {\n  \n  # Convert string representation of column name to symbol\n  xsym &lt;- ensym(indicator)\n  \n  result &lt;- wdi_in1 %&gt;% \n    # Compute summary stats\n    group_by(region, date) %&gt;% \n    dplyr::summarize(mean = wtd.mean({{xsym}}, pop),\n              sd = sqrt(wtd.var({{xsym}}, pop)),\n              min = min({{xsym}}, na.rm = TRUE),\n              max = max({{xsym}}, na.rm = TRUE),\n              median = median({{xsym}}, na.rm = TRUE),\n              pop = sum(pop, na.rm = TRUE)\n    ) %&gt;%\n   \n    # Pivot summary df to long format\n    pivot_longer(cols = c(mean, sd, min, max, median),\n                 names_to = \"estimate\",\n                 values_to = indicator) %&gt;% \n   \n    # Move \"estimate\" column to front\n    select(estimate, everything())\n   \n  return(result)\n}\n\nNow, apply “aggregate_stat” to the indicators of interest, generating a list of summary dataframes.\n\nagg_indicators &lt;- c(\"lifeex\", \"gdp\", \"pov_intl\")\n\nsummary_dfs &lt;- lapply(agg_indicators, aggregate_stat)\n\nFinally, merge these dataframes into the final product.\n\n# Define the common columns to merge by\ncommon_columns &lt;- c(\"estimate\", \"region\", \"date\", \"pop\")\n\n# Use Reduce and merge to merge the dataframes in the list\nmerged_dataframe &lt;- Reduce(function(x, y) merge(x, y, by = common_columns, all = TRUE), summary_dfs)\n\n# Re-order rows according to levels argument below\nwdi_agg_answer &lt;- merged_dataframe %&gt;% \n    mutate(estimate = factor(estimate, \n                            levels = c(\"mean\", \"sd\", \"min\", \"max\", \"median\"))) %&gt;% \n    arrange(estimate)\n\n# Display preview of answer\ndatatable(wdi_agg_answer, \n          options = list(pageLength = 10, lengthMenu = c(10, 20, 30), searching = TRUE), \n          style = \"bootstrap\",\n          class = \"display responsive nowrap\")%&gt;% \n  formatRound(columns=c(\"lifeex\", \"gdp\", \"pov_intl\"), digits=2)\n\n\n\n\n\n\n\n\n3. Find outliers\nDefine simple functions “hl”(high) and “ll” (low) which return a boolean depending on whether the submitted value is more than “sd_away” standard deviations away from the mean.\n\n# Specify standard deviation for outlier calculation here\nsd_away = 2.5\n\nhl &lt;- function(value, mean, sd) {\n  (value - mean) &gt; sd_away * sd\n}\n\nll &lt;- function(value, mean, sd) {\n  (value - mean) &lt; -(sd_away * sd)\n}\n\nNow, we specify our indicators of interest. Then, we perform the mean, sd, hl, and ll calculations across these indicators.\n\noutlier_indicators &lt;- c(\"lifeex\", \"gdp\", \"gini\")\n\nwdi_outliers_answer &lt;- wdi_in1 %&gt;%\n  group_by(date) %&gt;%\n  mutate_at(outlier_indicators, list(mean = ~wtd.mean(., pop), \n                                     sd = ~sqrt(wtd.var(., pop)),\n                                     hl = ~hl(., wtd.mean(., pop), sqrt(wtd.var(., pop))),\n                                     ll = ~ll(., wtd.mean(., pop), sqrt(wtd.var(., pop)))))\n\n# Display preview of answer\ndatatable(wdi_outliers_answer, \n          options = list(pageLength = 10, lengthMenu = c(10, 20, 30), searching = TRUE))\n\n\n\n\n\n\nPlot the results for “lifeex”.\n\n# Calculate confidence interval\nlifeex_conf_h &lt;- wdi_outliers_answer$lifeex_mean + (sd_away * wdi_outliers_answer$lifeex_sd)\nlifeex_conf_l &lt;- wdi_outliers_answer$lifeex_mean - (sd_away * wdi_outliers_answer$lifeex_sd)\n\n# Build chart\nggplot(wdi_outliers_answer, aes(x = date, y = lifeex, color = region)) +\n  geom_ribbon(aes(ymin = lifeex_conf_l, ymax = lifeex_conf_h), fill = \"grey\", alpha = 0.3, linetype = 0) +\n  geom_line(aes(y = lifeex_mean), color = \"blue\") +\n  geom_point() +\n  labs(title = \"Life Expectancy Over Time\",\n       x = \"Year\",\n       y = \"Life Expectancy\") +\n  theme_minimal() +\n  theme(legend.position = c(0.5, 0.2),\n        legend.title = element_blank(),\n        legend.direction = \"horizontal\",\n        plot.title = element_text(hjust = 0.5))\n\n\n\n\n\n\n\nSimulated data\n\nData download\n\nl_svy &lt;- readr::read_rds(paste0(data_url, \"svy_sim_in1.Rds\"))\n\ndt_pov_solution &lt;- readr::read_rds(paste0(data_url, \"dt_pov_out.Rds\"))\n\ndt_lorenz_solution &lt;- readr::read_rds(paste0(data_url, \"dt_lorenz_out.Rds\"))\n\ndt_gini_solution &lt;- readr::read_rds(paste0(data_url, \"dt_gini_out.Rds\"))\n\n\n\n4. Poverty measures\nFirst, define three simple functions for calculating poverty headcount, gap, and severity measures for a given dataframe and poverty line.\n\nheadcount &lt;- function(df, pov_line) {\n  result &lt;- sum(df$weight[df$income &lt; pov_line]) / sum(df$weight)\n  return(result)\n}\n\npovgap &lt;- function(df, pov_line) {\n  poor_pop &lt;- sum(df$weight[df$income &lt; pov_line])\n  total_pop &lt;- sum(df$weight)\n  poor_avg &lt;- wtd.mean(df$income[df$income &lt; pov_line], df$weight[df$income &lt; pov_line])\n  \n  result &lt;- (poor_pop/total_pop) * ((pov_line - poor_avg)/pov_line)\n  return(result)\n}\n\npovseverity &lt;- function(df, pov_line) {\n  poor_pop &lt;- sum(df$weight[df$income &lt; pov_line])\n  total_pop &lt;- sum(df$weight)\n  \n  poor_severity &lt;- sum(((pov_line - df$income[df$income &lt; pov_line]) / pov_line)^2 * df$weight[df$income &lt; pov_line])\n\n  result &lt;- (poor_severity / total_pop)\n  return(result)\n}\n\nNext, define a general function which uses the functions above to create a dataframe consolidating the poverty measure calculations.\n\ncalculate_poverty_measures &lt;- function(df, pov_line) {\n  result &lt;- data.frame(\n    pov_line = pov_line,\n    headcount = headcount(df, pov_line),\n    povgap = povgap(df, pov_line),\n    povseverity = povseverity(df, pov_line)\n  )\n  \n  return(result)\n}\n\nNow, define a list of poverty lines, and then apply the function created in the previous chunk to each yearly dataframe and poverty line.\n\n# Define poverty lines here\npov_lines &lt;- c(2.15, 3.65, 6.85)\n\n# Apply function to each dataframe and for each poverty line \npov_measures_list &lt;- lapply(l_svy, function(year_df) {\n  lapply(pov_lines, function(pov_line) {\n    calculate_poverty_measures(year_df, pov_line)\n  })\n})\n\n# Combine the results into a single dataframe\npov_measures_df &lt;- do.call(rbind, do.call(c, pov_measures_list))\n\n# Create and clean year column\ndt_pov_answer &lt;- pov_measures_df %&gt;% \n  tibble::rownames_to_column(var = \"year\") %&gt;% \n  mutate(year = as.numeric(substr(year, 2, 5))) %&gt;% \n  select(year, everything())\n\n# Display preview of answer\ndatatable(dt_pov_answer, \n          options = list(pageLength = 10, lengthMenu = c(10, 20, 30), searching = TRUE), \n          style = \"bootstrap\",\n          class = \"display responsive nowrap\")%&gt;% \n  formatRound(columns=c(\"headcount\", \"povgap\", \"povseverity\"), digits=2)\n\n\n\n\n\n\nPlotting poverty headcount over time.\n\nggplot(dt_pov_answer, aes(x = year, y = headcount, group = pov_line, color = as.factor(pov_line))) +\n  geom_line() +\n  geom_point() +\n  labs(title = \"Poverty Headcount Over Time\",\n       x = \"Year\",\n       y = \"Headcount\") +\n  theme_minimal() +\n  theme(legend.position = \"bottom\",\n        legend.title = element_blank(),\n        plot.title = element_text(hjust = 0.5))\n\n\n\n\n\n\n5. Lorenz curve\nDefine the Lorenz function, which will calculate the cumulative welfare at each percentile for a given dataframe.\n\nlorenz &lt;- function(df) {\n  \n  # Clean up yearly df and order by income\n  df &lt;- df %&gt;% \n    rename(population = weight) %&gt;% \n    select(income, population) %&gt;% \n    arrange(income)\n\n  # Number of percentiles you want\n  num_percentiles &lt;- 100\n  \n  # Calculate income thresholds for each percentile\n  percentile_thresholds &lt;- wtd.quantile(df$income, probs = seq(0, 1, length.out = num_percentiles + 1), weights = df$population)\n  \n  percentile_thresholds &lt;- percentile_thresholds[-1]\n  \n  # Empty Lorenz df\n  lorenz_df &lt;- data.frame(cum_welfare = numeric(0))\n  \n  # Calculate cumulative share of income, weighted by pop, for each percentile\n  for (i in 1:num_percentiles) {\n    \n    # Subset data for the current percentile\n    subset_data &lt;- df[df$income &lt;= percentile_thresholds[i], ]\n    \n    # Calculate cum_welfare\n    cum_welfare &lt;- sum(subset_data$income * subset_data$population) / sum(df$income * df$population)\n    \n    # Append to the Lorenz df\n    lorenz_df &lt;- rbind(lorenz_df, data.frame(cum_welfare = cum_welfare))\n  }\n  \n  # Add welfare, cum_pop, and year columns\n  result &lt;- lorenz_df %&gt;% \n    mutate(welfare = percentile_thresholds,\n           cum_population = seq(0.01, 1, by = 0.01)) %&gt;% \n    select(welfare, cum_welfare, cum_population)\n  \n  return(result)\n}\n\nApply the Lorenz function to the list of yearly dataframes.\n\n# Empty list for modified dataframes\nlorenz_list &lt;- list()\n\n# Loop over the list of yearly dataframes\nfor (i in seq_along(l_svy)) {\n  # Apply Lorenz function\n  lorenz_df &lt;- lorenz(l_svy[[i]])\n  \n  # Add year column\n  year &lt;- names(l_svy)[i]\n  lorenz_df$year &lt;- as.numeric(substr(year, 2, 5))\n  \n  # Append to list\n  lorenz_list[[i]] &lt;- lorenz_df\n}\n\n# Bind into single, final df\ndt_lorenz_answer &lt;- bind_rows(lorenz_list)\n\n# Display preview of answer\ndatatable(dt_lorenz_answer, \n          options = list(pageLength = 10, lengthMenu = c(10, 20, 30), searching = TRUE), \n          style = \"bootstrap\",\n          class = \"display responsive nowrap\")%&gt;% \n  formatRound(columns=c(\"welfare\", \"cum_population\"), digits=2)\n\n\n\n\n\n\nPlot the Lorenz curves.\n\nggplot(dt_lorenz_answer, aes(x = cum_population, y = cum_welfare, group = year, color = as.factor(year))) +\n  geom_line() +\n  labs(title = \"Lorenz Curves 2001-2010\",\n       x = \"Cumulative Population\",\n       y = \"Cumulative Welfare\") +\n  theme_minimal() +\n  theme(legend.position = c(0.1, 0.6),\n        legend.direction = \"vertical\",\n        legend.title = element_blank(),\n        plot.title = element_text(hjust = 0.5))\n\n\n\n\n\n\n6. Gini coefficient\nDefine function to calculate the Gini coefficient for a given dataframe.\n\ncalculate_gini &lt;- function (df) {\n  \n  # Arrange by income and normalize the weights\n  df &lt;- df %&gt;% \n    arrange(income) %&gt;% \n    mutate(weight = weight/sum(weight))\n  \n  # Calculate cumulative sums\n  cum_weights &lt;- cumsum(df$weight)\n  cum_inc_wtd &lt;- cumsum(df$weight * df$income)\n  \n  # Normalize\n  n &lt;- length(cum_inc_wtd)\n  cum_inc_wtd &lt;- cum_inc_wtd/cum_inc_wtd[n]\n  \n  # Calculate coefficient\n  result &lt;- sum(cum_inc_wtd[-1] * cum_weights[-n]) - sum(cum_inc_wtd[-n] * cum_weights[-1])\n  \n  return(result)\n}\n\nApply the Gini function to the list of yearly dataframes.\n\n# Empty list for coefficients\ngini_list &lt;- list()\n\nfor (i in seq_along(l_svy)) {\n  \n  # Apply Gini function\n  gini_coef &lt;- calculate_gini(l_svy[[i]])\n  \n  # Get year\n  year &lt;- names(l_svy)[i]\n  year &lt;- as.numeric(substr(year, 2, 5))\n  \n  # Add to dataframe\n  gini_df &lt;- data.frame(year = year, gini = gini_coef)\n  \n  # Append to list\n  gini_list[[i]] &lt;- gini_df\n  \n}\n\n# Bind into single, final df\ndt_gini_answer &lt;- bind_rows(gini_list)\n\n# Display preview of answer\ndatatable(dt_gini_answer, \n          options = list(pageLength = 10, lengthMenu = c(10, 20, 30), searching = TRUE), \n          style = \"bootstrap\",\n          class = \"display responsive nowrap\")%&gt;% \n  formatRound(columns=c(\"gini\"), digits=4)\n\n\n\n\n\n\nPlot the Gini coefficients.\n\nggplot(dt_gini_answer, aes(x = year, y = gini)) +\n  geom_point() +\n  geom_line() +\n  labs(title = \"Gini Coefficients 2001-2010\",\n       x = \"Year\",\n       y = \"Gini Coefficient\") +\n  theme_minimal() +\n  theme(plot.title = element_text(hjust = 0.5))"
  },
  {
    "objectID": "index.html#r-assessment-for-stc-position-at-global-poverty-and-inequality-data-team",
    "href": "index.html#r-assessment-for-stc-position-at-global-poverty-and-inequality-data-team",
    "title": "WB_STC_R_Quarto",
    "section": "",
    "text": "Author: Nolan Young Zabala\nContact: youngnolan1@gmail.com\n\n\n\nlibrary(waldo)\nlibrary(dplyr)\n\nWarning: package 'dplyr' was built under R version 4.1.2\n\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(Hmisc)\n\nLoading required package: lattice\n\n\nLoading required package: survival\n\n\nLoading required package: Formula\n\n\n\nAttaching package: 'Hmisc'\n\n\nThe following objects are masked from 'package:dplyr':\n\n    src, summarize\n\n\nThe following objects are masked from 'package:base':\n\n    format.pval, units\n\nlibrary(DT)\n\n*Note: package “Hmisc” is used for weighted mean and variance calculations. Like “dplyr”, it contains the function “summarize” - so make sure to use “dplyr:summarize” to avoid confusing errors.\n\n\n\n\n\n\ntag      &lt;- \"202311081903\"\nbase_url &lt;- \"https://github.com/randrescastaneda/pub_data/raw/\"\ndata_url &lt;- paste0(base_url, tag, \"/data/Rtest1/\")\n\n\nwdi_in1 &lt;- readr::read_rds(paste0(data_url, \"wdi_in1.Rds\"))\n\nwdi_summ_solution &lt;- readr::read_rds(paste0(data_url, \"wdi_summ_out.Rds\"))\n\nwdi_agg_solution &lt;- readr::read_rds(paste0(data_url, \"wdi_agg_out.Rds\"))\n\nwdi_outliers_solution &lt;- readr::read_rds(paste0(data_url, \"wdi_outliers_out.Rds\"))\n\n\n\n\n`summarise()` has grouped output by 'region'. You can override using the\n`.groups` argument.\n\n\n\n\n\n\n\n\nFirst, define function “aggregate_stat” - Arguments: “indicator” is the name of indicator of interest as a string. - Output: returns “result”, a long-format dataframe containing population-weighted summary statistics for the indicator of interest.\n\naggregate_stat &lt;- function(indicator) {\n  \n  # Convert string representation of column name to symbol\n  xsym &lt;- ensym(indicator)\n  \n  result &lt;- wdi_in1 %&gt;% \n    # Compute summary stats\n    group_by(region, date) %&gt;% \n    dplyr::summarize(mean = wtd.mean({{xsym}}, pop),\n              sd = sqrt(wtd.var({{xsym}}, pop)),\n              min = min({{xsym}}, na.rm = TRUE),\n              max = max({{xsym}}, na.rm = TRUE),\n              median = median({{xsym}}, na.rm = TRUE),\n              pop = sum(pop, na.rm = TRUE)\n    ) %&gt;%\n   \n    # Pivot summary df to long format\n    pivot_longer(cols = c(mean, sd, min, max, median),\n                 names_to = \"estimate\",\n                 values_to = indicator) %&gt;% \n   \n    # Move \"estimate\" column to front\n    select(estimate, everything())\n   \n  return(result)\n}\n\nNow, apply “aggregate_stat” to the indicators of interest, generating a list of summary dataframes.\n\nagg_indicators &lt;- c(\"lifeex\", \"gdp\", \"pov_intl\")\n\nsummary_dfs &lt;- lapply(agg_indicators, aggregate_stat)\n\n`summarise()` has grouped output by 'region'. You can override using the\n`.groups` argument.`summarise()` has grouped output by 'region'. You can\noverride using the `.groups` argument.`summarise()` has grouped output by\n'region'. You can override using the `.groups` argument.\n\n\nFinally, merge these dataframes into the final product.\n\n# Define the common columns to merge by\ncommon_columns &lt;- c(\"estimate\", \"region\", \"date\", \"pop\")\n\n# Use Reduce and merge to merge the dataframes in the list\nmerged_dataframe &lt;- Reduce(function(x, y) merge(x, y, by = common_columns, all = TRUE), summary_dfs)\n\n# Re-order rows according to levels argument below\nwdi_agg_answer &lt;- merged_dataframe %&gt;% \n    mutate(estimate = factor(estimate, \n                            levels = c(\"mean\", \"sd\", \"min\", \"max\", \"median\"))) %&gt;% \n    arrange(estimate)\n\n# Display preview of answer\ndatatable(wdi_agg_answer, \n          options = list(pageLength = 10, lengthMenu = c(10, 20, 30), searching = TRUE), \n          style = \"bootstrap\",\n          class = \"display responsive nowrap\")%&gt;% \n  formatRound(columns=c(\"lifeex\", \"gdp\", \"pov_intl\"), digits=2)\n\n\n\n\n\n# waldo::compare(wdi_agg_solution, wdi_agg_answer)\n\n\n\n\nDefine simple functions “hl”(high) and “ll” (low) which return a boolean depending on whether the submitted value is more than “sd_away” standard deviations away from the mean.\n\n# Specify standard deviation for outlier calculation here\nsd_away = 2.5\n\nhl &lt;- function(value, mean, sd) {\n  (value - mean) &gt; sd_away * sd\n}\n\nll &lt;- function(value, mean, sd) {\n  (value - mean) &lt; -(sd_away * sd)\n}\n\nNow, we specify our indicators of interest. Then, we perform the mean, sd, hl, and ll calculations across these indicators.\n\noutlier_indicators &lt;- c(\"lifeex\", \"gdp\", \"gini\")\n\nwdi_outliers_answer &lt;- wdi_in1 %&gt;%\n  group_by(date) %&gt;%\n  mutate_at(outlier_indicators, list(mean = ~wtd.mean(., pop), \n                                     sd = ~sqrt(wtd.var(., pop)),\n                                     hl = ~hl(., wtd.mean(., pop), sqrt(wtd.var(., pop))),\n                                     ll = ~ll(., wtd.mean(., pop), sqrt(wtd.var(., pop)))))\n\n# Display preview of answer\ndatatable(wdi_outliers_answer, \n          options = list(pageLength = 10, lengthMenu = c(10, 20, 30), searching = TRUE))%&gt;% \n  formatRound(columns = names(wdi_outliers_answer), digits=2)\n\n\n\n\n\n# waldo::compare(wdi_outliers_solution, wdi_outliers_answer)\n\nPlot the results for “lifeex”.\n\n# Calculate confidence interval\nlifeex_conf_h &lt;- wdi_outliers_answer$lifeex_mean + (sd_away * wdi_outliers_answer$lifeex_sd)\nlifeex_conf_l &lt;- wdi_outliers_answer$lifeex_mean - (sd_away * wdi_outliers_answer$lifeex_sd)\n\n# Build chart\nggplot(wdi_outliers_answer, aes(x = date, y = lifeex, color = region)) +\n  geom_ribbon(aes(ymin = lifeex_conf_l, ymax = lifeex_conf_h), fill = \"grey\", alpha = 0.3, linetype = 0) +\n  geom_line(aes(y = lifeex_mean), color = \"blue\") +\n  geom_point() +\n  labs(title = \"Life Expectancy Over Time\",\n       x = \"Year\",\n       y = \"Life Expectancy\") +\n  theme_minimal() +\n  theme(legend.position = c(0.5, 0.2),\n        legend.title = element_blank(),\n        legend.direction = \"horizontal\",\n        plot.title = element_text(hjust = 0.5))\n\n\n\n\n\n\n\n\n\n\n\nl_svy &lt;- readr::read_rds(paste0(data_url, \"svy_sim_in1.Rds\"))\n\ndt_pov_solution &lt;- readr::read_rds(paste0(data_url, \"dt_pov_out.Rds\"))\n\ndt_lorenz_solution &lt;- readr::read_rds(paste0(data_url, \"dt_lorenz_out.Rds\"))\n\ndt_gini_solution &lt;- readr::read_rds(paste0(data_url, \"dt_gini_out.Rds\"))\n\n\n\n\nFirst, define three simple functions for calculating poverty headcount, gap, and severity measures.\n\nheadcount &lt;- function(df, pov_line) {\n  result &lt;- sum(df$weight[df$income &lt; pov_line]) / sum(df$weight)\n  return(result)\n}\n\npovgap &lt;- function(df, pov_line) {\n  poor_pop &lt;- sum(df$weight[df$income &lt; pov_line])\n  total_pop &lt;- sum(df$weight)\n  poor_avg &lt;- wtd.mean(df$income[df$income &lt; pov_line], df$weight[df$income &lt; pov_line])\n  \n  result &lt;- (poor_pop/total_pop) * ((pov_line - poor_avg)/pov_line)\n  return(result)\n}\n\npovseverity &lt;- function(df, pov_line) {\n  poor_pop &lt;- sum(df$weight[df$income &lt; pov_line])\n  total_pop &lt;- sum(df$weight)\n  \n  poor_severity &lt;- sum(((pov_line - df$income[df$income &lt; pov_line]) / pov_line)^2 * df$weight[df$income &lt; pov_line])\n\n  result &lt;- (poor_severity / total_pop)\n  return(result)\n}\n\nNext, define a general function which calculates poverty measures for a given dataframe and poverty line.\n\ncalculate_poverty_measures &lt;- function(df, pov_line) {\n  result &lt;- data.frame(\n    pov_line = pov_line,\n    headcount = headcount(df, pov_line),\n    povgap = povgap(df, pov_line),\n    povseverity = povseverity(df, pov_line)\n  )\n  \n  return(result)\n}\n\nNow, define a list of poverty lines, and then apply the function created in the previous chunk to each yearly dataframe and poverty line.\n\n# Define poverty lines here\npov_lines &lt;- c(2.15, 3.65, 6.85)\n\n# Apply function to each dataframe and for each poverty line \npov_measures_list &lt;- lapply(l_svy, function(year_df) {\n  lapply(pov_lines, function(pov_line) {\n    calculate_poverty_measures(year_df, pov_line)\n  })\n})\n\n# Combine the results into a single dataframe\npov_measures_df &lt;- do.call(rbind, do.call(c, pov_measures_list))\n\n# Create and clean year column\ndt_pov_answer &lt;- pov_measures_df %&gt;% \n  tibble::rownames_to_column(var = \"year\") %&gt;% \n  mutate(year = as.numeric(substr(year, 2, 5))) %&gt;% \n  select(year, everything())\n\n# Display preview of answer\ndatatable(dt_pov_answer, \n          options = list(pageLength = 10, lengthMenu = c(10, 20, 30), searching = TRUE), \n          style = \"bootstrap\",\n          class = \"display responsive nowrap\")%&gt;% \n  formatRound(columns=c(\"headcount\", \"povgap\", \"povseverity\"), digits=2)\n\n\n\n\n\n# waldo::compare(dt_pov_solution, dt_pov_answer)\n\nPlotting poverty headcount over time.\n\nggplot(dt_pov_answer, aes(x = year, y = headcount, group = pov_line, color = as.factor(pov_line))) +\n  geom_line() +\n  geom_point() +\n  labs(title = \"Poverty Headcount Over Time\",\n       x = \"Year\",\n       y = \"Headcount\") +\n  theme_minimal() +\n  theme(legend.position = \"bottom\",\n        legend.title = element_blank(),\n        plot.title = element_text(hjust = 0.5))\n\n\n\n\n\n\n\nDefine the Lorenz function, which will calculate the cumulative welfare at each percentile for a given dataframe.\n\nlorenz &lt;- function(df) {\n  \n  # Clean up yearly df and order by income\n  df &lt;- df %&gt;% \n    rename(population = weight) %&gt;% \n    select(income, population) %&gt;% \n    arrange(income)\n\n  # Number of percentiles you want\n  num_percentiles &lt;- 100\n  \n  # Calculate income thresholds for each percentile\n  percentile_thresholds &lt;- wtd.quantile(df$income, probs = seq(0, 1, length.out = num_percentiles + 1), weights = df$population)\n  \n  percentile_thresholds &lt;- percentile_thresholds[-1]\n  \n  # Empty Lorenz df\n  lorenz_df &lt;- data.frame(cum_welfare = numeric(0))\n  \n  # Calculate cumulative share of income, weighted by pop, for each percentile\n  for (i in 1:num_percentiles) {\n    \n    # Subset data for the current percentile\n    subset_data &lt;- df[df$income &lt;= percentile_thresholds[i], ]\n    \n    # Calculate cum_welfare\n    cum_welfare &lt;- sum(subset_data$income * subset_data$population) / sum(df$income * df$population)\n    \n    # Append to the Lorenz df\n    lorenz_df &lt;- rbind(lorenz_df, data.frame(cum_welfare = cum_welfare))\n  }\n  \n  # Add welfare, cum_pop, and year columns\n  result &lt;- lorenz_df %&gt;% \n    mutate(welfare = percentile_thresholds,\n           cum_population = seq(0.01, 1, by = 0.01)) %&gt;% \n    select(welfare, cum_welfare, cum_population)\n  \n  return(result)\n}\n\nApply the Lorenz function to the list of yearly dataframes.\n\n# Empty list for modified dataframes\nlorenz_list &lt;- list()\n\nfor (i in seq_along(l_svy)) {\n  # Apply Lorenz function\n  lorenz_df &lt;- lorenz(l_svy[[i]])\n  \n  # Add year column\n  year &lt;- names(l_svy)[i]\n  lorenz_df$year &lt;- as.numeric(substr(year, 2, 5))\n  \n  # Append to list\n  lorenz_list[[i]] &lt;- lorenz_df\n}\n\n# Bind into single, final df\ndt_lorenz_answer &lt;- bind_rows(lorenz_list)\n\n# Display preview of answer\ndatatable(dt_lorenz_answer, \n          options = list(pageLength = 10, lengthMenu = c(10, 20, 30), searching = TRUE), \n          style = \"bootstrap\",\n          class = \"display responsive nowrap\")%&gt;% \n  formatRound(columns=c(\"welfare\", \"cum_population\"), digits=2)\n\n\n\n\n\n# waldo::compare(dt_lorenz_solution, dt_lorenz_answer)\n\nPlot the Lorenz curves.\n\nggplot(dt_lorenz_answer, aes(x = cum_population, y = cum_welfare, group = year, color = as.factor(year))) +\n  geom_line() +\n  labs(title = \"Lorenz Curves 2001-2010\",\n       x = \"Cumulative Population\",\n       y = \"Cumulative Welfare\") +\n  theme_minimal() +\n  theme(legend.position = c(0.1, 0.6),\n        legend.direction = \"vertical\",\n        legend.title = element_blank(),\n        plot.title = element_text(hjust = 0.5))\n\n\n\n\n\n\n\nDefine function to calculate the Gini coefficient.\n\ncalculate_gini &lt;- function (df) {\n  \n  # Arrange by income and normalize the weights\n  df &lt;- df %&gt;% \n    arrange(income) %&gt;% \n    mutate(weight = weight/sum(weight))\n  \n  # Calculate cumulative sums\n  cum_weights &lt;- cumsum(df$weight)\n  cum_inc_wtd &lt;- cumsum(df$weight * df$income)\n  \n  # Normalize\n  n &lt;- length(cum_inc_wtd)\n  cum_inc_wtd &lt;- cum_inc_wtd/cum_inc_wtd[n]\n  \n  # Calculate coefficient\n  result &lt;- sum(cum_inc_wtd[-1] * cum_weights[-n]) - sum(cum_inc_wtd[-n] * cum_weights[-1])\n  \n  return(result)\n}\n\nApply the Gini function to the list of yearly dataframes.\n\n# Empty list for coefficients\ngini_list &lt;- list()\n\nfor (i in seq_along(l_svy)) {\n  \n  # Apply Gini function\n  gini_coef &lt;- calculate_gini(l_svy[[i]])\n  \n  # Get year\n  year &lt;- names(l_svy)[i]\n  year &lt;- as.numeric(substr(year, 2, 5))\n  \n  # Add to dataframe\n  gini_df &lt;- data.frame(year = year, gini = gini_coef)\n  \n  # Append to list\n  gini_list[[i]] &lt;- gini_df\n  \n}\n\n# Bind into single, final df\ndt_gini_answer &lt;- bind_rows(gini_list)\n\n# Display preview of answer\ndatatable(dt_gini_answer, \n          options = list(pageLength = 10, lengthMenu = c(10, 20, 30), searching = TRUE), \n          style = \"bootstrap\",\n          class = \"display responsive nowrap\")%&gt;% \n  formatRound(columns=c(\"gini\"), digits=4)\n\n\n\n\n\n# waldo::compare(dt_gini_solution, dt_gini_answer)\n\nPlot the Gini coefficients.\n\nggplot(dt_gini_answer, aes(x = year, y = gini)) +\n  geom_point() +\n  geom_line() +\n  labs(title = \"Gini Coefficients 2001-2010\",\n       x = \"Year\",\n       y = \"Gini Coefficient\") +\n  theme_minimal() +\n  theme(plot.title = element_text(hjust = 0.5))"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  }
]